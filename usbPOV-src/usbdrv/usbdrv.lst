   1               		.file	"usbdrv.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  94               		.section	.text.usbInit,"ax",@progbits
  96               	.global	usbInit
  98               	usbInit:
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8:usbdrv/usbdrv.c ****  * This Revision: $Id: usbdrv.c 791 2010-07-15 15:56:13Z cs $
   9:usbdrv/usbdrv.c ****  */
  10:usbdrv/usbdrv.c **** 
  11:usbdrv/usbdrv.c **** #include "usbportability.h"
  12:usbdrv/usbdrv.c **** #include "usbdrv.h"
  13:usbdrv/usbdrv.c **** #include "oddebug.h"
  14:usbdrv/usbdrv.c **** 
  15:usbdrv/usbdrv.c **** /*
  16:usbdrv/usbdrv.c **** General Description:
  17:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  18:usbdrv/usbdrv.c **** documentation of the entire driver.
  19:usbdrv/usbdrv.c **** */
  20:usbdrv/usbdrv.c **** 
  21:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  22:usbdrv/usbdrv.c **** 
  23:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  24:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  25:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  26:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  27:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  28:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  29:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  30:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  31:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  32:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  33:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  34:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  35:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  36:usbdrv/usbdrv.c **** #endif
  37:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  38:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  39:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  40:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  41:usbdrv/usbdrv.c **** #   endif
  42:usbdrv/usbdrv.c **** #endif
  43:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  44:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  45:usbdrv/usbdrv.c **** #endif
  46:usbdrv/usbdrv.c **** 
  47:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  48:usbdrv/usbdrv.c **** uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  49:usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  50:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  51:usbdrv/usbdrv.c **** 
  52:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  53:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  54:usbdrv/usbdrv.c **** 
  55:usbdrv/usbdrv.c **** /*
  56:usbdrv/usbdrv.c **** optimizing hints:
  57:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  58:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  59:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  60:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  61:usbdrv/usbdrv.c **** */
  62:usbdrv/usbdrv.c **** 
  63:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  64:usbdrv/usbdrv.c **** 
  65:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  66:usbdrv/usbdrv.c **** 
  67:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  68:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  69:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  70:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorString0[] = { /* language descriptor */
  71:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  72:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  73:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  74:usbdrv/usbdrv.c **** };
  75:usbdrv/usbdrv.c **** #endif
  76:usbdrv/usbdrv.c **** 
  77:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  78:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  79:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  80:usbdrv/usbdrv.c **** PROGMEM int  usbDescriptorStringVendor[] = {
  81:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  82:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  83:usbdrv/usbdrv.c **** };
  84:usbdrv/usbdrv.c **** #endif
  85:usbdrv/usbdrv.c **** 
  86:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  87:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  88:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  89:usbdrv/usbdrv.c **** PROGMEM int  usbDescriptorStringDevice[] = {
  90:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  91:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  92:usbdrv/usbdrv.c **** };
  93:usbdrv/usbdrv.c **** #endif
  94:usbdrv/usbdrv.c **** 
  95:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  96:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  97:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  98:usbdrv/usbdrv.c **** PROGMEM int usbDescriptorStringSerialNumber[] = {
  99:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 100:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 101:usbdrv/usbdrv.c **** };
 102:usbdrv/usbdrv.c **** #endif
 103:usbdrv/usbdrv.c **** 
 104:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 105:usbdrv/usbdrv.c **** 
 106:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 107:usbdrv/usbdrv.c **** 
 108:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 109:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 110:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 111:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
 112:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 113:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 114:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 116:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 117:usbdrv/usbdrv.c ****     0,                      /* protocol */
 118:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 119:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 120:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 121:usbdrv/usbdrv.c ****      */
 122:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 123:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 124:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 125:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 126:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 127:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 128:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 129:usbdrv/usbdrv.c **** };
 130:usbdrv/usbdrv.c **** #endif
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 133:usbdrv/usbdrv.c **** 
 134:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 135:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 136:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 137:usbdrv/usbdrv.c **** #endif
 138:usbdrv/usbdrv.c **** 
 139:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 140:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 141:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 142:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 143:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 144:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 145:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 146:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 147:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 148:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 149:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 150:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 151:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 152:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 153:usbdrv/usbdrv.c **** #else
 154:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 155:usbdrv/usbdrv.c **** #endif
 156:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 157:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 158:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 159:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 160:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 161:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 162:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 164:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 165:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 166:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 167:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 168:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 169:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 170:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 171:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 172:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 173:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 174:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 175:usbdrv/usbdrv.c **** #endif
 176:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 177:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 178:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 179:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 180:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 181:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 182:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 183:usbdrv/usbdrv.c **** #endif
 184:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 185:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 186:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 187:usbdrv/usbdrv.c ****     (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
 188:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 189:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 190:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 191:usbdrv/usbdrv.c **** #endif
 192:usbdrv/usbdrv.c **** };
 193:usbdrv/usbdrv.c **** #endif
 194:usbdrv/usbdrv.c **** 
 195:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 196:usbdrv/usbdrv.c **** 
 197:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 198:usbdrv/usbdrv.c **** {
 199:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 201:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 202:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 203:usbdrv/usbdrv.c **** #   endif
 204:usbdrv/usbdrv.c **** #endif
 205:usbdrv/usbdrv.c **** }
 206:usbdrv/usbdrv.c **** 
 207:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 208:usbdrv/usbdrv.c **** {
 209:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 210:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 211:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 212:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 213:usbdrv/usbdrv.c **** #endif
 214:usbdrv/usbdrv.c **** #endif
 215:usbdrv/usbdrv.c **** }
 216:usbdrv/usbdrv.c **** 
 217:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 218:usbdrv/usbdrv.c **** 
 219:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 220:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 221:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 222:usbdrv/usbdrv.c **** {
 223:usbdrv/usbdrv.c **** uchar   *p;
 224:usbdrv/usbdrv.c **** char    i;
 225:usbdrv/usbdrv.c **** 
 226:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 227:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 228:usbdrv/usbdrv.c ****         return;
 229:usbdrv/usbdrv.c **** #endif
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 232:usbdrv/usbdrv.c ****     }else{
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 234:usbdrv/usbdrv.c ****     }
 235:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 236:usbdrv/usbdrv.c ****     i = len;
 237:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 242:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 243:usbdrv/usbdrv.c **** }
 244:usbdrv/usbdrv.c **** 
 245:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 246:usbdrv/usbdrv.c **** {
 247:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 248:usbdrv/usbdrv.c **** }
 249:usbdrv/usbdrv.c **** #endif
 250:usbdrv/usbdrv.c **** 
 251:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 252:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 253:usbdrv/usbdrv.c **** {
 254:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 255:usbdrv/usbdrv.c **** }
 256:usbdrv/usbdrv.c **** #endif
 257:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 258:usbdrv/usbdrv.c **** 
 259:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 260:usbdrv/usbdrv.c **** 
 261:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 262:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 263:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 264:usbdrv/usbdrv.c ****  * cases.
 265:usbdrv/usbdrv.c ****  */
 266:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 267:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 268:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 269:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 270:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 271:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 272:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 273:usbdrv/usbdrv.c **** #else
 274:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 275:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 276:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 277:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 278:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 279:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 280:usbdrv/usbdrv.c **** #endif
 281:usbdrv/usbdrv.c **** 
 282:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 283:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 284:usbdrv/usbdrv.c **** #endif
 285:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 286:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 287:usbdrv/usbdrv.c **** #endif
 288:usbdrv/usbdrv.c **** 
 289:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 290:usbdrv/usbdrv.c **** 
 291:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 292:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 293:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 294:usbdrv/usbdrv.c ****  * optimizing!
 295:usbdrv/usbdrv.c ****  */
 296:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 297:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 298:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 299:usbdrv/usbdrv.c ****             flags = 0;                              \
 300:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 301:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 302:usbdrv/usbdrv.c ****         }else{                                      \
 303:usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 304:usbdrv/usbdrv.c ****             usbMsgPtr = (uchar *)(staticName);      \
 305:usbdrv/usbdrv.c ****         }                                           \
 306:usbdrv/usbdrv.c ****     }
 307:usbdrv/usbdrv.c **** 
 308:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 309:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 310:usbdrv/usbdrv.c ****  */
 311:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 312:usbdrv/usbdrv.c **** {
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 314:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 315:usbdrv/usbdrv.c **** 
 316:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 322:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 323:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 324:usbdrv/usbdrv.c ****             flags = 0;
 325:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 326:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 327:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 334:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 335:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 336:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 337:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 338:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 339:usbdrv/usbdrv.c ****             }
 340:usbdrv/usbdrv.c ****         SWITCH_END
 341:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 342:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 346:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 347:usbdrv/usbdrv.c **** #endif
 348:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 349:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 350:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 351:usbdrv/usbdrv.c ****         }
 352:usbdrv/usbdrv.c ****     SWITCH_END
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 354:usbdrv/usbdrv.c ****     return len;
 355:usbdrv/usbdrv.c **** }
 356:usbdrv/usbdrv.c **** 
 357:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 358:usbdrv/usbdrv.c **** 
 359:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 360:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 361:usbdrv/usbdrv.c ****  */
 362:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 363:usbdrv/usbdrv.c **** {
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 366:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 367:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 368:usbdrv/usbdrv.c **** #endif
 369:usbdrv/usbdrv.c **** 
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 373:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 374:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 375:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 376:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 377:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 378:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 379:usbdrv/usbdrv.c **** #endif
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 381:usbdrv/usbdrv.c ****         len = 2;
 382:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 383:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 384:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 385:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 386:usbdrv/usbdrv.c ****             usbResetDataToggling();
 387:usbdrv/usbdrv.c ****         }
 388:usbdrv/usbdrv.c **** #endif
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 391:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 393:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 394:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 397:usbdrv/usbdrv.c ****         len = 1;
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 400:usbdrv/usbdrv.c ****         usbResetStall();
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 402:usbdrv/usbdrv.c ****         len = 1;
 403:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 405:usbdrv/usbdrv.c ****         usbResetDataToggling();
 406:usbdrv/usbdrv.c ****         usbResetStall();
 407:usbdrv/usbdrv.c **** #endif
 408:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 409:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 410:usbdrv/usbdrv.c ****     SWITCH_END
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 412:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 413:usbdrv/usbdrv.c ****     return len;
 414:usbdrv/usbdrv.c **** }
 415:usbdrv/usbdrv.c **** 
 416:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 417:usbdrv/usbdrv.c **** 
 418:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 419:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 420:usbdrv/usbdrv.c ****  * them accordingly.
 421:usbdrv/usbdrv.c ****  */
 422:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 423:usbdrv/usbdrv.c **** {
 424:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 425:usbdrv/usbdrv.c **** 
 426:usbdrv/usbdrv.c **** /* usbRxToken can be:
 427:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 428:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 429:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 430:usbdrv/usbdrv.c ****  */
 431:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 432:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 433:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 434:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 435:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 436:usbdrv/usbdrv.c ****         return;
 437:usbdrv/usbdrv.c ****     }
 438:usbdrv/usbdrv.c **** #endif
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 441:usbdrv/usbdrv.c ****             return;
 442:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 449:usbdrv/usbdrv.c ****         }else{
 450:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 451:usbdrv/usbdrv.c ****         }
 452:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 453:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 454:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 455:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 456:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 457:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 458:usbdrv/usbdrv.c ****                 }else{
 459:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 460:usbdrv/usbdrv.c ****                 }
 461:usbdrv/usbdrv.c ****             }
 462:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 463:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 464:usbdrv/usbdrv.c **** #endif
 465:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 466:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 467:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 468:usbdrv/usbdrv.c ****         }else{
 469:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 470:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 471:usbdrv/usbdrv.c ****         }
 472:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 473:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 474:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 475:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 476:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 477:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 478:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 479:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 480:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 481:usbdrv/usbdrv.c ****             }
 482:usbdrv/usbdrv.c ****         }
 483:usbdrv/usbdrv.c **** #endif
 484:usbdrv/usbdrv.c ****     }
 485:usbdrv/usbdrv.c **** }
 486:usbdrv/usbdrv.c **** 
 487:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 488:usbdrv/usbdrv.c **** 
 489:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 490:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 491:usbdrv/usbdrv.c ****  */
 492:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 493:usbdrv/usbdrv.c **** {
 494:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 495:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 496:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 497:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 498:usbdrv/usbdrv.c ****         }else
 499:usbdrv/usbdrv.c **** #endif
 500:usbdrv/usbdrv.c ****         {
 501:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 503:usbdrv/usbdrv.c ****                 do{
 504:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 506:usbdrv/usbdrv.c ****                     r++;
 507:usbdrv/usbdrv.c ****                 }while(--i);
 508:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 509:usbdrv/usbdrv.c ****                 do{
 510:usbdrv/usbdrv.c ****                     *data++ = *r++;
 511:usbdrv/usbdrv.c ****                 }while(--i);
 512:usbdrv/usbdrv.c ****             }
 513:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 514:usbdrv/usbdrv.c ****         }
 515:usbdrv/usbdrv.c ****     }
 516:usbdrv/usbdrv.c ****     return len;
 517:usbdrv/usbdrv.c **** }
 518:usbdrv/usbdrv.c **** 
 519:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 520:usbdrv/usbdrv.c **** 
 521:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 522:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 523:usbdrv/usbdrv.c ****  */
 524:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 525:usbdrv/usbdrv.c **** {
 526:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 527:usbdrv/usbdrv.c **** uchar       len;
 528:usbdrv/usbdrv.c **** 
 529:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 530:usbdrv/usbdrv.c ****     if(wantLen > 8)
 531:usbdrv/usbdrv.c ****         wantLen = 8;
 532:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 534:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 535:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 540:usbdrv/usbdrv.c ****     }else{
 541:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 542:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 543:usbdrv/usbdrv.c ****     }
 544:usbdrv/usbdrv.c ****     usbTxLen = len;
 545:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 546:usbdrv/usbdrv.c **** }
 547:usbdrv/usbdrv.c **** 
 548:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 549:usbdrv/usbdrv.c **** 
 550:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 551:usbdrv/usbdrv.c **** {
 552:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 553:usbdrv/usbdrv.c **** static uchar    wasReset;
 554:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 555:usbdrv/usbdrv.c **** 
 556:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 557:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 558:usbdrv/usbdrv.c ****         wasReset = isReset;
 559:usbdrv/usbdrv.c ****     }
 560:usbdrv/usbdrv.c **** #endif
 561:usbdrv/usbdrv.c **** }
 562:usbdrv/usbdrv.c **** 
 563:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 564:usbdrv/usbdrv.c **** 
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 566:usbdrv/usbdrv.c **** {
 567:usbdrv/usbdrv.c **** schar   len;
 568:usbdrv/usbdrv.c **** uchar   i;
 569:usbdrv/usbdrv.c **** 
 570:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 571:usbdrv/usbdrv.c ****     if(len >= 0){
 572:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 573:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 574:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 575:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 576:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 577:usbdrv/usbdrv.c ****  */
 578:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 579:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 580:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 581:usbdrv/usbdrv.c ****             usbRxLen = 0;
 582:usbdrv/usbdrv.c **** #else
 583:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 584:usbdrv/usbdrv.c **** #endif
 585:usbdrv/usbdrv.c ****     }
 586:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 587:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 588:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 589:usbdrv/usbdrv.c ****         }
 590:usbdrv/usbdrv.c ****     }
 591:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 593:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 594:usbdrv/usbdrv.c ****             goto isNotReset;
 595:usbdrv/usbdrv.c ****     }
 596:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 597:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 598:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 599:usbdrv/usbdrv.c ****     usbResetStall();
 600:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 601:usbdrv/usbdrv.c **** isNotReset:
 602:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 603:usbdrv/usbdrv.c **** }
 604:usbdrv/usbdrv.c **** 
 605:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 606:usbdrv/usbdrv.c **** 
 607:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 608:usbdrv/usbdrv.c **** {
  99               	68,0,608,.LM0-.LFBB1
 100               	.LM0:
 101               	.LFBB1:
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 609:usbdrv/usbdrv.c **** _INTR_CFG_CLR);
 610:usbdrv/usbdrv.c **** #endif
 104               	bn	68,0,610,.LM1-.LFBB1
 105               	.LM1:
 106 0000 E9E6      		ldi r30,lo8(105)
 107 0002 F0E0      		ldi r31,hi8(105)
 108 0004 8081      		ld r24,Z
 109 0006 8260      		ori r24,lo8(2)
 110 0008 8083      		st Z,r24
 611:usbdrv/usbdrv.c **** R);
 612:usbdrv/usbdrv.c **** #endif
 613:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 614:usbdrv/usbdrv.c ****     usbResetDataToggling();
 615:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 111               		68,0,615,.LM2-.LFBB1
 112               	.LM2:
 113 000a E89A      		sbi 61-32,0
 114               	.LBB61:
 115               	.LBB62:
 117               	.LM3:
 118 000c 8BE4      		ldi r24,lo8(75)
 119 000e 8093 0000 		sts usbTxStatus1+1,r24
 120               	.LBE62:
 121               	.LBE61:
 616:usbdrv/usbdrv.c **** TR_CODE
 617:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 618:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 122               	0,618,.LM4-.LFBB1
 123               	.LM4:
 124 0012 8AE5      		ldi r24,lo8(90)
 125 0014 8093 0000 		sts usbTxStatus1,r24
 126               	/* epilogue start */
 619:usbdrv/usbdrv.c **** OINT3
 620:usbdrv/usbdrv.c ****     usbTxLen3 = USBPID_NAK;
 621:usbdrv/usbdrv.c **** #endif
 622:usbdrv/usbdrv.c **** #endif
 623:usbdrv/usbdrv.c **** }
 127               	bn	68,0,623,.LM5-.LFBB1
 128               	.LM5:
 129 0018 0895      		ret
 131               	.Lscope1:
 132               		.section	.text.usbSetInterrupt,"ax",@progbits
 136               	.global	usbSetInterrupt
 138               	usbSetInterrupt:
 140               	.LM6:
 141               	.LFBB2:
 142 0000 1F93      		push r17
 143               	/* prologue: function */
 144               	/* frame size = 0 */
 145 0002 DC01      		movw r26,r24
 146 0004 162F      		mov r17,r22
 147               	.LBB63:
 148               	.LBB64:
 150               	.LM7:
 151 0006 8091 0000 		lds r24,usbTxStatus1
 152 000a 84FF      		sbrs r24,4
 153 000c 00C0      		rjmp .L4
 155               	.LM8:
 156 000e 8091 0000 		lds r24,usbTxStatus1+1
 157 0012 98E8      		ldi r25,lo8(-120)
 158 0014 8927      		eor r24,r25
 159 0016 8093 0000 		sts usbTxStatus1+1,r24
 160 001a 00C0      		rjmp .L5
 161               	.L4:
 163               	.LM9:
 164 001c 8AE5      		ldi r24,lo8(90)
 165 001e 8093 0000 		sts usbTxStatus1,r24
 166               	.L5:
 167 0022 912F      		mov r25,r17
 168 0024 E0E0      		ldi r30,lo8(usbTxStatus1+2)
 169 0026 F0E0      		ldi r31,hi8(usbTxStatus1+2)
 170               	.L6:
 172               	.LM10:
 173 0028 8D91      		ld r24,X+
 174 002a 8193      		st Z+,r24
 176               	.LM11:
 177 002c 9150      		subi r25,lo8(-(-1))
 178 002e 01F4      		brne .L6
 180               	.LM12:
 181 0030 80E0      		ldi r24,lo8(usbTxStatus1+2)
 182 0032 90E0      		ldi r25,hi8(usbTxStatus1+2)
 183 0034 612F      		mov r22,r17
 184 0036 00D0      		rcall usbCrc16Append
 186               	.LM13:
 187 0038 1C5F      		subi r17,lo8(-(4))
 188 003a 1093 0000 		sts usbTxStatus1,r17
 189               	/* epilogue start */
 190               	.LBE64:
 191               	.LBE63:
 193               	.LM14:
 194 003e 1F91      		pop r17
 195 0040 0895      		ret
 197               	.Lscope2:
 198               		.section	.text.usbPoll,"ax",@progbits
 200               	.global	usbPoll
 202               	usbPoll:
 204               	.LM15:
 205               	.LFBB3:
 206 0000 1F93      		push r17
 207 0002 CF93      		push r28
 208 0004 DF93      		push r29
 209               	/* prologue: function */
 210               	/* frame size = 0 */
 212               	.LM16:
 213 0006 6091 0000 		lds r22,usbRxLen
 214 000a 6350      		subi r22,lo8(-(-3))
 216               	.LM17:
 217 000c 67FD      		sbrc r22,7
 218 000e 00C0      		rjmp .L10
 220               	.LM18:
 221 0010 8091 0000 		lds r24,usbInputBufOffset
 222 0014 CCE0      		ldi r28,lo8(12)
 223 0016 D0E0      		ldi r29,hi8(12)
 224 0018 C81B      		sub r28,r24
 225 001a D109      		sbc r29,__zero_reg__
 226 001c C050      		subi r28,lo8(-(usbRxBuf))
 227 001e D040      		sbci r29,hi8(-(usbRxBuf))
 228               	.LBB65:
 229               	.LBB66:
 231               	.LM19:
 232 0020 8091 0000 		lds r24,usbRxToken
 233 0024 8D32      		cpi r24,lo8(45)
 234 0026 01F0      		breq .+2
 235 0028 00C0      		rjmp .L11
 236               	.LBB68:
 238               	.LM20:
 239 002a 6830      		cpi r22,lo8(8)
 240 002c 01F0      		breq .+2
 241 002e 00C0      		rjmp .L12
 243               	.LM21:
 244 0030 83EC      		ldi r24,lo8(-61)
 245 0032 8093 0000 		sts usbTxBuf,r24
 247               	.LM22:
 248 0036 8AE5      		ldi r24,lo8(90)
 249 0038 8093 0000 		sts usbTxLen,r24
 251               	.LM23:
 252 003c 1092 0000 		sts usbMsgFlags,__zero_reg__
 254               	.LM24:
 255 0040 8881      		ld r24,Y
 256 0042 8076      		andi r24,lo8(96)
 257 0044 01F0      		breq .L13
 258               	.LBE68:
 259               	.LBE66:
 261               	.LM25:
 262 0046 CE01      		movw r24,r28
 263 0048 00D0      		rcall usbFunctionSetup
 264 004a 282F      		mov r18,r24
 265               	.LBB80:
 266               	.LBB67:
 268               	.LM26:
 269 004c 8F3F      		cpi r24,lo8(-1)
 270 004e 01F4      		brne .+2
 271 0050 00C0      		rjmp .L14
 272 0052 00C0      		rjmp .L15
 273               	.L13:
 274               	.LBB69:
 275               	.LBB70:
 277               	.LM27:
 278 0054 9A81      		ldd r25,Y+2
 280               	.LM28:
 281 0056 1092 0000 		sts usbTxBuf+9,__zero_reg__
 282               	.LBB71:
 284               	.LM29:
 285 005a 8981      		ldd r24,Y+1
 287               	.LM30:
 288 005c 8823      		tst r24
 289 005e 01F4      		brne .L16
 290               	.LBB72:
 292               	.LM31:
 293 0060 1092 0000 		sts usbTxBuf+10,__zero_reg__
 294 0064 22E0      		ldi r18,lo8(2)
 295 0066 00C0      		rjmp .L53
 296               	.L16:
 297               	.LBE72:
 299               	.LM32:
 300 0068 8530      		cpi r24,lo8(5)
 301 006a 01F4      		brne .L18
 303               	.LM33:
 304 006c 9093 0000 		sts usbNewDeviceAddr,r25
 305 0070 00C0      		rjmp .L55
 306               	.L18:
 308               	.LM34:
 309 0072 8630      		cpi r24,lo8(6)
 310 0074 01F0      		breq .+2
 311 0076 00C0      		rjmp .L19
 312               	.LBB73:
 313               	.LBB74:
 314               	.LBB75:
 316               	.LM35:
 317 0078 8B81      		ldd r24,Y+3
 319               	.LM36:
 320 007a 8130      		cpi r24,lo8(1)
 321 007c 01F4      		brne .L20
 323               	.LM37:
 324 007e 80E0      		ldi r24,lo8(usbDescriptorDevice)
 325 0080 90E0      		ldi r25,hi8(usbDescriptorDevice)
 326 0082 9093 0000 		sts (usbMsgPtr)+1,r25
 327 0086 8093 0000 		sts usbMsgPtr,r24
 328 008a 22E1      		ldi r18,lo8(18)
 329 008c 00C0      		rjmp .L21
 330               	.L20:
 332               	.LM38:
 333 008e 8230      		cpi r24,lo8(2)
 334 0090 01F4      		brne .L22
 336               	.LM39:
 337 0092 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 338 0094 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 339 0096 9093 0000 		sts (usbMsgPtr)+1,r25
 340 009a 8093 0000 		sts usbMsgPtr,r24
 341 009e 22E2      		ldi r18,lo8(34)
 342 00a0 00C0      		rjmp .L21
 343               	.L22:
 345               	.LM40:
 346 00a2 8330      		cpi r24,lo8(3)
 347 00a4 01F4      		brne .L23
 348               	.LBB76:
 350               	.LM41:
 351 00a6 8A81      		ldd r24,Y+2
 353               	.LM42:
 354 00a8 8823      		tst r24
 355 00aa 01F4      		brne .L24
 357               	.LM43:
 358 00ac 80E0      		ldi r24,lo8(usbDescriptorString0)
 359 00ae 90E0      		ldi r25,hi8(usbDescriptorString0)
 360 00b0 9093 0000 		sts (usbMsgPtr)+1,r25
 361 00b4 8093 0000 		sts usbMsgPtr,r24
 362 00b8 24E0      		ldi r18,lo8(4)
 363 00ba 00C0      		rjmp .L21
 364               	.L24:
 366               	.LM44:
 367 00bc 8130      		cpi r24,lo8(1)
 368 00be 01F4      		brne .L25
 370               	.LM45:
 371 00c0 80E0      		ldi r24,lo8(usbDescriptorStringVendor)
 372 00c2 90E0      		ldi r25,hi8(usbDescriptorStringVendor)
 373 00c4 9093 0000 		sts (usbMsgPtr)+1,r25
 374 00c8 8093 0000 		sts usbMsgPtr,r24
 375 00cc 2AE1      		ldi r18,lo8(26)
 376 00ce 00C0      		rjmp .L21
 377               	.L25:
 379               	.LM46:
 380 00d0 8230      		cpi r24,lo8(2)
 381 00d2 01F4      		brne .L26
 383               	.LM47:
 384 00d4 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 385 00d6 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 386 00d8 9093 0000 		sts (usbMsgPtr)+1,r25
 387 00dc 8093 0000 		sts usbMsgPtr,r24
 388 00e0 20E1      		ldi r18,lo8(16)
 389 00e2 00C0      		rjmp .L21
 390               	.L23:
 391               	.LBE76:
 393               	.LM48:
 394 00e4 8132      		cpi r24,lo8(33)
 395 00e6 01F4      		brne .L27
 397               	.LM49:
 398 00e8 80E0      		ldi r24,lo8(usbDescriptorConfiguration+18)
 399 00ea 90E0      		ldi r25,hi8(usbDescriptorConfiguration+18)
 400 00ec 9093 0000 		sts (usbMsgPtr)+1,r25
 401 00f0 8093 0000 		sts usbMsgPtr,r24
 402 00f4 29E0      		ldi r18,lo8(9)
 403 00f6 00C0      		rjmp .L21
 404               	.L27:
 406               	.LM50:
 407 00f8 8232      		cpi r24,lo8(34)
 408 00fa 01F4      		brne .L26
 410               	.LM51:
 411 00fc 80E0      		ldi r24,lo8(usbDescriptorHidReport)
 412 00fe 90E0      		ldi r25,hi8(usbDescriptorHidReport)
 413 0100 9093 0000 		sts (usbMsgPtr)+1,r25
 414 0104 8093 0000 		sts usbMsgPtr,r24
 415 0108 21E2      		ldi r18,lo8(33)
 416 010a 00C0      		rjmp .L21
 417               	.L26:
 418 010c 20E0      		ldi r18,lo8(0)
 419               	.L21:
 420               	.LBE75:
 422               	.LM52:
 423 010e 80E4      		ldi r24,lo8(64)
 424 0110 8093 0000 		sts usbMsgFlags,r24
 425 0114 00C0      		rjmp .L15
 426               	.L19:
 427               	.LBE74:
 428               	.LBE73:
 430               	.LM53:
 431 0116 8830      		cpi r24,lo8(8)
 432 0118 01F4      		brne .L28
 433 011a 21E0      		ldi r18,lo8(1)
 434 011c 80E0      		ldi r24,lo8(usbConfiguration)
 435 011e 90E0      		ldi r25,hi8(usbConfiguration)
 436 0120 00C0      		rjmp .L17
 437               	.L28:
 439               	.LM54:
 440 0122 8930      		cpi r24,lo8(9)
 441 0124 01F4      		brne .L29
 443               	.LM55:
 444 0126 9093 0000 		sts usbConfiguration,r25
 445 012a 00C0      		rjmp .L55
 446               	.L29:
 448               	.LM56:
 449 012c 8A30      		cpi r24,lo8(10)
 450 012e 01F4      		brne .L30
 451 0130 21E0      		ldi r18,lo8(1)
 452 0132 00C0      		rjmp .L53
 453               	.L30:
 455               	.LM57:
 456 0134 8B30      		cpi r24,lo8(11)
 457 0136 01F4      		brne .L55
 458               	.L31:
 459               	.LBB77:
 460               	.LBB78:
 462               	.LM58:
 463 0138 8BE4      		ldi r24,lo8(75)
 464 013a 8093 0000 		sts usbTxStatus1+1,r24
 465               	.L55:
 466 013e 20E0      		ldi r18,lo8(0)
 467               	.L53:
 468 0140 80E0      		ldi r24,lo8(usbTxBuf+9)
 469 0142 90E0      		ldi r25,hi8(usbTxBuf+9)
 470               	.L17:
 471               	.LBE78:
 472               	.LBE77:
 473               	.LBE71:
 475               	.LM59:
 476 0144 9093 0000 		sts (usbMsgPtr)+1,r25
 477 0148 8093 0000 		sts usbMsgPtr,r24
 478 014c 00C0      		rjmp .L15
 479               	.L14:
 480               	.LBE70:
 481               	.LBE69:
 483               	.LM60:
 484 014e 8881      		ld r24,Y
 485 0150 87FD      		sbrc r24,7
 487               	.LM61:
 488 0152 2E81      		ldd r18,Y+6
 489               	.L32:
 491               	.LM62:
 492 0154 80E8      		ldi r24,lo8(-128)
 493 0156 8093 0000 		sts usbMsgFlags,r24
 494 015a 00C0      		rjmp .L34
 495               	.L15:
 497               	.LM63:
 498 015c 8F81      		ldd r24,Y+7
 499 015e 8823      		tst r24
 500 0160 01F4      		brne .L34
 501 0162 8E81      		ldd r24,Y+6
 502 0164 8217      		cp r24,r18
 503 0166 00F0      		brlo .L33
 504               	.L34:
 505 0168 822F      		mov r24,r18
 506               	.L33:
 508               	.LM64:
 509 016a 8093 0000 		sts usbMsgLen,r24
 510 016e 00C0      		rjmp .L12
 511               	.L11:
 512               	.LBE67:
 514               	.LM65:
 515 0170 8091 0000 		lds r24,usbMsgFlags
 516 0174 87FF      		sbrs r24,7
 517 0176 00C0      		rjmp .L12
 518               	.LBE80:
 520               	.LM66:
 521 0178 CE01      		movw r24,r28
 522 017a 00D0      		rcall usbFunctionWrite
 523               	.LBB81:
 524               	.LBB79:
 526               	.LM67:
 527 017c 8F3F      		cpi r24,lo8(-1)
 528 017e 01F4      		brne .L35
 530               	.LM68:
 531 0180 8EE1      		ldi r24,lo8(30)
 532 0182 8093 0000 		sts usbTxLen,r24
 533 0186 00C0      		rjmp .L12
 534               	.L35:
 536               	.LM69:
 537 0188 8823      		tst r24
 538 018a 01F0      		breq .L12
 540               	.LM70:
 541 018c 1092 0000 		sts usbMsgLen,__zero_reg__
 542               	.L12:
 543               	.LBE79:
 544               	.LBE81:
 545               	.LBE65:
 547               	.LM71:
 548 0190 1092 0000 		sts usbRxLen,__zero_reg__
 549               	.L10:
 551               	.LM72:
 552 0194 8091 0000 		lds r24,usbTxLen
 553 0198 84FF      		sbrs r24,4
 554 019a 00C0      		rjmp .L36
 556               	.LM73:
 557 019c 8091 0000 		lds r24,usbMsgLen
 558 01a0 8F3F      		cpi r24,lo8(-1)
 559 01a2 01F4      		brne .+2
 560 01a4 00C0      		rjmp .L36
 561 01a6 182F      		mov r17,r24
 562 01a8 8930      		cpi r24,lo8(9)
 563 01aa 00F0      		brlo .L37
 564 01ac 18E0      		ldi r17,lo8(8)
 565               	.L37:
 566               	.LBB82:
 567               	.LBB83:
 569               	.LM74:
 570 01ae 811B      		sub r24,r17
 571 01b0 8093 0000 		sts usbMsgLen,r24
 573               	.LM75:
 574 01b4 8091 0000 		lds r24,usbTxBuf
 575 01b8 98E8      		ldi r25,lo8(-120)
 576 01ba 8927      		eor r24,r25
 577 01bc 8093 0000 		sts usbTxBuf,r24
 578               	.LBB84:
 579               	.LBB85:
 581               	.LM76:
 582 01c0 1123      		tst r17
 583 01c2 01F0      		breq .L38
 585               	.LM77:
 586 01c4 8091 0000 		lds r24,usbMsgFlags
 587 01c8 87FF      		sbrs r24,7
 588 01ca 00C0      		rjmp .L39
 589               	.LBE85:
 591               	.LM78:
 592 01cc 80E0      		ldi r24,lo8(usbTxBuf+1)
 593 01ce 90E0      		ldi r25,hi8(usbTxBuf+1)
 594 01d0 612F      		mov r22,r17
 595 01d2 00D0      		rcall usbFunctionRead
 596 01d4 182F      		mov r17,r24
 597               	.LBE84:
 599               	.LM79:
 600 01d6 8930      		cpi r24,lo8(9)
 601 01d8 00F4      		brsh .L52
 602 01da 00C0      		rjmp .L38
 603               	.L39:
 604               	.LBB90:
 605               	.LBB89:
 606               	.LBB86:
 608               	.LM80:
 609 01dc 2091 0000 		lds r18,usbMsgPtr
 610 01e0 3091 0000 		lds r19,(usbMsgPtr)+1
 612               	.LM81:
 613 01e4 86FF      		sbrs r24,6
 614 01e6 00C0      		rjmp .L41
 615 01e8 A0E0      		ldi r26,lo8(usbTxBuf+1)
 616 01ea B0E0      		ldi r27,hi8(usbTxBuf+1)
 617 01ec 80E0      		ldi r24,lo8(0)
 618 01ee 90E0      		ldi r25,hi8(0)
 619               	.L42:
 620               	.LBB87:
 621               	.LBB88:
 623               	.LM82:
 624 01f0 F901      		movw r30,r18
 625 01f2 E80F      		add r30,r24
 626 01f4 F91F      		adc r31,r25
 627               	/* #APP */
 628               	 ;  504 "usbdrv/usbdrv.c" 1
 629 01f6 E491      		lpm r30, Z
 630               		
 631               	 ;  0 "" 2
 632               	/* #NOAPP */
 633               	.LBE88:
 635               	.LM83:
 636 01f8 ED93      		st X+,r30
 637 01fa 0196      		adiw r24,1
 638               	.LBE87:
 640               	.LM84:
 641 01fc 1817      		cp r17,r24
 642 01fe 01F4      		brne .L42
 643 0200 00C0      		rjmp .L54
 644               	.L41:
 645 0202 912F      		mov r25,r17
 646 0204 D901      		movw r26,r18
 647 0206 E0E0      		ldi r30,lo8(usbTxBuf+1)
 648 0208 F0E0      		ldi r31,hi8(usbTxBuf+1)
 649               	.L44:
 651               	.LM85:
 652 020a 8D91      		ld r24,X+
 653 020c 8193      		st Z+,r24
 655               	.LM86:
 656 020e 9150      		subi r25,lo8(-(-1))
 657 0210 01F4      		brne .L44
 658               	.L54:
 659 0212 1150      		subi r17,lo8(-(-1))
 660 0214 812F      		mov r24,r17
 661 0216 90E0      		ldi r25,lo8(0)
 662 0218 1F5F      		subi r17,lo8(-(1))
 663 021a 0196      		adiw r24,1
 664 021c 820F      		add r24,r18
 665 021e 931F      		adc r25,r19
 667               	.LM87:
 668 0220 9093 0000 		sts (usbMsgPtr)+1,r25
 669 0224 8093 0000 		sts usbMsgPtr,r24
 670               	.L38:
 671               	.LBE86:
 672               	.LBE89:
 673               	.LBE90:
 675               	.LM88:
 676 0228 80E0      		ldi r24,lo8(usbTxBuf+1)
 677 022a 90E0      		ldi r25,hi8(usbTxBuf+1)
 678 022c 612F      		mov r22,r17
 679 022e 00D0      		rcall usbCrc16Append
 681               	.LM89:
 682 0230 612F      		mov r22,r17
 683 0232 6C5F      		subi r22,lo8(-(4))
 685               	.LM90:
 686 0234 6C30      		cpi r22,lo8(12)
 687 0236 01F0      		breq .L45
 689               	.LM91:
 690 0238 8FEF      		ldi r24,lo8(-1)
 691 023a 8093 0000 		sts usbMsgLen,r24
 692 023e 00C0      		rjmp .L45
 693               	.L52:
 695               	.LM92:
 696 0240 8FEF      		ldi r24,lo8(-1)
 697 0242 8093 0000 		sts usbMsgLen,r24
 698 0246 6EE1      		ldi r22,lo8(30)
 699               	.L45:
 701               	.LM93:
 702 0248 6093 0000 		sts usbTxLen,r22
 703               	.L36:
 704 024c 94E1      		ldi r25,lo8(20)
 705               	.L47:
 706               	.LBE83:
 707               	.LBE82:
 708               	.LBB91:
 710               	.LM94:
 711 024e 89B1      		in r24,41-32
 713               	.LM95:
 714 0250 8474      		andi r24,lo8(68)
 715 0252 01F4      		brne .L48
 716               	.LBE91:
 718               	.LM96:
 719 0254 9150      		subi r25,lo8(-(-1))
 720 0256 01F4      		brne .L47
 722               	.LM97:
 723 0258 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 725               	.LM98:
 726 025c 1092 0000 		sts usbDeviceAddr,__zero_reg__
 727               	.L48:
 728               	/* epilogue start */
 730               	.LM99:
 731 0260 DF91      		pop r29
 732 0262 CF91      		pop r28
 733 0264 1F91      		pop r17
 734 0266 0895      		ret
 776               	.Lscope3:
 777               	.global	usbTxLen
 778               		.data
 781               	usbTxLen:
 782 0000 5A        		.byte	90
 783               	.global	usbDescriptorString0
 784               		.section	.progmem.data,"a",@progbits
 787               	usbDescriptorString0:
 788 0000 04        		.byte	4
 789 0001 03        		.byte	3
 790 0002 09        		.byte	9
 791 0003 04        		.byte	4
 792               	.global	usbDescriptorStringVendor
 795               	usbDescriptorStringVendor:
 796 0004 1A03      		.word	794
 797 0006 5500      		.word	85
 798 0008 4300      		.word	67
 799 000a 6100      		.word	97
 800 000c 6C00      		.word	108
 801 000e 6700      		.word	103
 802 0010 6100      		.word	97
 803 0012 7200      		.word	114
 804 0014 7900      		.word	121
 805 0016 2D00      		.word	45
 806 0018 5A00      		.word	90
 807 001a 6F00      		.word	111
 808 001c 6F00      		.word	111
 809               	.global	usbDescriptorStringDevice
 812               	usbDescriptorStringDevice:
 813 001e 1003      		.word	784
 814 0020 5500      		.word	85
 815 0022 5300      		.word	83
 816 0024 4200      		.word	66
 817 0026 2D00      		.word	45
 818 0028 5000      		.word	80
 819 002a 4F00      		.word	79
 820 002c 5600      		.word	86
 821               	.global	usbDescriptorDevice
 824               	usbDescriptorDevice:
 825 002e 12        		.byte	18
 826 002f 01        		.byte	1
 827 0030 10        		.byte	16
 828 0031 01        		.byte	1
 829 0032 00        		.byte	0
 830 0033 00        		.byte	0
 831 0034 00        		.byte	0
 832 0035 08        		.byte	8
 833 0036 C0        		.byte	-64
 834 0037 16        		.byte	22
 835 0038 DF        		.byte	-33
 836 0039 05        		.byte	5
 837 003a 00        		.byte	0
 838 003b 02        		.byte	2
 839 003c 01        		.byte	1
 840 003d 02        		.byte	2
 841 003e 00        		.byte	0
 842 003f 01        		.byte	1
 843               	.global	usbDescriptorConfiguration
 846               	usbDescriptorConfiguration:
 847 0040 09        		.byte	9
 848 0041 02        		.byte	2
 849 0042 22        		.byte	34
 850 0043 00        		.byte	0
 851 0044 01        		.byte	1
 852 0045 01        		.byte	1
 853 0046 00        		.byte	0
 854 0047 80        		.byte	-128
 855 0048 0A        		.byte	10
 856 0049 09        		.byte	9
 857 004a 04        		.byte	4
 858 004b 00        		.byte	0
 859 004c 00        		.byte	0
 860 004d 01        		.byte	1
 861 004e 03        		.byte	3
 862 004f 00        		.byte	0
 863 0050 00        		.byte	0
 864 0051 00        		.byte	0
 865 0052 09        		.byte	9
 866 0053 21        		.byte	33
 867 0054 01        		.byte	1
 868 0055 01        		.byte	1
 869 0056 00        		.byte	0
 870 0057 01        		.byte	1
 871 0058 22        		.byte	34
 872 0059 21        		.byte	33
 873 005a 00        		.byte	0
 874 005b 07        		.byte	7
 875 005c 05        		.byte	5
 876 005d 81        		.byte	-127
 877 005e 03        		.byte	3
 878 005f 08        		.byte	8
 879 0060 00        		.byte	0
 880 0061 64        		.byte	100
 881               		.data
 884               	usbMsgLen:
 885 0001 FF        		.byte	-1
 886               		.lcomm usbMsgFlags,1
 887               		.comm usbMsgPtr,2,1
 888               		.comm usbRxToken,1,1
 889               		.comm usbConfiguration,1,1
 890               		.comm usbTxStatus1,12,1
 891               		.comm usbRxBuf,22,1
 892               		.comm usbInputBufOffset,1,1
 893               		.comm usbDeviceAddr,1,1
 894               		.comm usbNewDeviceAddr,1,1
 895               		.comm usbRxLen,1,1
 896               		.comm usbCurrentTok,1,1
 897               		.comm usbTxBuf,11,1
 917               		.text
 919               	.Letext0:
 920               	.global __do_copy_data
 921               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 usbdrv.c
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:2      *ABS*:0000003f __SREG__
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:3      *ABS*:0000003e __SP_H__
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:4      *ABS*:0000003d __SP_L__
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:5      *ABS*:00000034 __CCP__
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:98     .text.usbInit:00000000 usbInit
                            *COM*:0000000c usbTxStatus1
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:138    .text.usbSetInterrupt:00000000 usbSetInterrupt
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:202    .text.usbPoll:00000000 usbPoll
                            *COM*:00000001 usbRxLen
                            *COM*:00000001 usbInputBufOffset
                            *COM*:00000016 usbRxBuf
                            *COM*:00000001 usbRxToken
                            *COM*:0000000b usbTxBuf
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:781    .data:00000000 usbTxLen
                             .bss:00000000 usbMsgFlags
                            *COM*:00000001 usbNewDeviceAddr
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:824    .progmem.data:0000002e usbDescriptorDevice
                            *COM*:00000002 usbMsgPtr
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:846    .progmem.data:00000040 usbDescriptorConfiguration
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:787    .progmem.data:00000000 usbDescriptorString0
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:795    .progmem.data:00000004 usbDescriptorStringVendor
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:812    .progmem.data:0000001e usbDescriptorStringDevice
                            *COM*:00000001 usbConfiguration
C:\Users\Ryan\AppData\Local\Temp/ccQ3u6JF.s:884    .data:00000001 usbMsgLen
                            *COM*:00000001 usbDeviceAddr
                            *COM*:00000001 usbCurrentTok

UNDEFINED SYMBOLS
usbCrc16Append
usbFunctionSetup
usbDescriptorHidReport
usbFunctionWrite
usbFunctionRead
__do_copy_data
__do_clear_bss
